/***************************************************************************** 
 *
 * The main program and support library for a compiler course.
 * Written by Craig C. Douglas
 *
 * Functions that are designed to be called from the code generated by a
 * compiler from one of my compiler courses are the following (if a routine
 * in this file is not listed here, please do not call it):
 *
 *      f24_exit        Prints final statistics and exits
 *      allocate_in_Mem Free memory in the heap
 *      calc_math       Calculates a math function and returns a double
 *      free_in_Mem     Free memory in the heap
 *      get_int         Reads a C type int and returns it
 *      get_double      Reads a C type double and returns it
 *      get_string      Reads a C type character string and returns its length
 *      print_int       Print a C type int
 *      print_double    Print a C type double
 *      print_string    Print a C type character string
 *
 * The main program calls a user supplied your_main function that is included
 * in this compilation through a #include directive.
 *
 *****************************************************************************/

#include <stdlib.h>
#include <stdio.h>
#include <stdint.h>
#include <math.h>
#include <string.h>

/***************************************************************************** 
 *
 * Memory and register definitions
 *
 *****************************************************************************/

#define F24_MemSize     1024000
#define F24_RSize       32
#define F24_FSize       16
#define F24_SbufSize    1025

double  F[F24_FSize];           /* Floaing point registers          */
int     R[F24_RSize];           /* Integer registers                */
int64_t Mem[F24_MemSize];       /* Memory                           */
int     F24_Time;               /* Timer                            */
char    SBuf[F24_SbufSize];     /* String input buffer              */

double *FMem;                   /* Floating point version of Mem    */
char   *SMem;                   /* String version of Mem            */

int     SR;                     /* Stack register                   */
int     FR;                     /* Frame register                   */
 
#define Allocate_Block_Free     6123
#define Allocate_Block_InUse    5531
#define Allocate_Block_Last     -8
#define Allocate_Block_Fail     0
#define Allocate_Block_Header   2

int Allocated_Blocks = 0;
int Freed_Blocks = 0;
int Combined_Blocks = 0;
int in_Mem_not_initialized = 1;
int in_Mem_debug = 0;

/***************************************************************************** 
 *
 * Run time support for exiting:
 *
 *     f24_exit
 *
 *****************************************************************************/

void f24_exit( int rc ) {

    /*****************************************************************
     *
     * Print final statistics:
     *     -  Timing information
     *     -  Return code
     *
     ****************************************************************/

    printf( "\n\nf24_exit called. Statistics follow:\n");
    printf( "    Return code      = %d\n",rc );
    printf( "    F24_Time         = %d\n", F24_Time );
    printf( "    Allocated Blocks = %d\n", Allocated_Blocks );
    printf( "    Freed Blocks     = %d\n", Freed_Blocks );
    if ( in_Mem_debug ) {
        printf( "    Combined Blocks  = %d\n", Combined_Blocks );
    }

    exit( rc );
}


/***************************************************************************** 
 *
 * Run time support for input/output:
 *
 *     print_string
 *     print_int
 *     print_double
 *     get_string
 *     get_int
 *     get_double
 *
 *****************************************************************************/

void print_string( char* s ) {

    /*****************************************************************
     *
     * Print a string
     *
     ****************************************************************/

    printf( "%s", s );

}

void print_int( int n ) {

    /*****************************************************************
     *
     * Print an integer
     *
     ****************************************************************/

    printf( "%d", n );

}

void print_double( double d ) {

    /*****************************************************************
     *
     * Print a double
     *
     ****************************************************************/

    printf( "%22.15le", d );

}

int get_int() {

    /*****************************************************************
     *
     * Read an integer
     *
     ****************************************************************/

    int     rc;

    scanf( "%d", &rc );
    return rc;
}

double get_double() {

    /*****************************************************************
     *
     * Read a double
     *
     ****************************************************************/

    double  rc;

    scanf( "%le", &rc );
    return rc;
}

int get_string() {

    /*****************************************************************
     *
     * Read a string and return its length. The actual string is in
     * in the global variable SBuf
     *
     ****************************************************************/

    int     rc;

    scanf( "%s", SBuf);
    return strlen( SBuf );
}


/***************************************************************************** 
 *
 * Run time support for math functions
 *
 *****************************************************************************/

enum {  F24_Calc_Abs,           /* abs(d1)                          */
        F24_Calc_Pow,           /* pow(d1,d2)                       */
        F24_Calc_Sqrt           /* sqrt(d1)                         */
     };


double calc_math( int fn, double d1, double d2 ) {

    /*****************************************************************
     *
     * Calculate one of the following:
     *
     *    - Absolute value of d1
     *    - d1 raised to the power d2
     *    - Square root of d1
     *
     ****************************************************************/

    switch ( fn ) {
        case F24_Calc_Abs:
            return fabs( d1 );

        case F24_Calc_Pow:
            return pow( d1, d2 );

        case F24_Calc_Sqrt:
            return sqrt( d1 );

        default:
            printf( "Illegal math function %d in calc_math\n", fn );
            f24_exit( -1 );
    }
    return 0.0;
}


/***************************************************************************** 
 *
 * Run time support for dynamic memory allocation
 *
 *     check_in_Mem
 *     init_in_Mem
 *     combine_in_Mem
 *     allocate_in_Mem
 *     free_in_Mem
 *
 * Each memory block has a two word header that contains
 *     -  Free/In use indicator
 *     -  Where the next block header begins or that this is the last block
 *
 *****************************************************************************/

int check_in_Mem( int pr_opt, char *msg ) {

    /*****************************************************************
     *
     * Check memory in the heap.
     *
     *    - Walk through the heap printing optionally printing what
     *      is there
     *    - Return 0 if it is intact, 1 otherwise
     *
     ****************************************************************/

    int     hdr;
    int     htype;
    char   *husage[] = { " Free", "InUse" };

    if ( in_Mem_not_initialized ) {
        printf( "check_in_Mem: heap not initialized\n" );
        f24_exit( 5 );
    }
    if ( pr_opt )
        printf( "check_in_Mem heap information by block [%s]\n", msg );
    for ( hdr = 0 ;
          Mem[hdr] == Allocate_Block_Free ||
              Mem[hdr] == Allocate_Block_InUse ;
          hdr = Mem[hdr+1] ) {
        if ( pr_opt ) {
            htype = Mem[hdr] == Allocate_Block_Free ? 0 : 1;
            printf( "    %6d hdr   = %s, hdr+1 = %d\n",
                    hdr, husage[htype], (int)Mem[hdr+1] );
        }
        if ( Mem[hdr+1] == Allocate_Block_Last ) break;
    }

    if ( Mem[hdr] == Allocate_Block_Free ||
         Mem[hdr] == Allocate_Block_InUse )
        return 0;

    return 1;
}


void init_in_Mem() {

    if ( in_Mem_not_initialized ) {
        Mem[0] = Allocate_Block_Free;
        Mem[1] = Allocate_Block_Last;
    }
    in_Mem_not_initialized = 0;
}

void combine_in_Mem( int hdr ) {

    /*****************************************************************
     *
     * Combine adjacent free memory blocks together starting at a
     * valid heap header
     *
     ****************************************************************/

    int     next_hdr;
    int     first_hdr;

    next_hdr = Mem[hdr+1];
    if ( next_hdr == Allocate_Block_Last ) return;

    for ( first_hdr = hdr ;
          Mem[next_hdr] == Allocate_Block_Free ;
          next_hdr  = Mem[first_hdr+1] ) {
        Mem[first_hdr+1] = Mem[next_hdr+1];
        Combined_Blocks++;
        if ( Mem[first_hdr+1] == Allocate_Block_Last ) break;
    }
}

int allocate_in_Mem( int nints ) {

    /*****************************************************************
     *
     * Allocate a block of memory in the heap
     *    - Fail unless nints is a natural number
     *    - Always allocate an even number of memory words
     *    - Combine adjacent Free blocks
     *    - Mark block as InUse if it is big enough
     *    - Keep searching if the block is too small
     *    - Return the index into Mem for where to put data if
     *      space is available, Fail otherwise
     *    - Increment counter for allocated blocks
     *
     ****************************************************************/

    int     hdr;
    int     next_hdr;
    int     rc;

    rc = Allocate_Block_Fail;
    if ( nints <= 0 )
        return rc;

    if ( nints % 2 ) nints++;

    for ( hdr = 0 ;
          Mem[hdr] == Allocate_Block_Free ||
              Mem[hdr] == Allocate_Block_InUse ;
          hdr = Mem[hdr+1] ) {
        next_hdr = hdr + 2 + nints;
        if ( Mem[hdr] == Allocate_Block_Free ) {
            combine_in_Mem( hdr );
            if ( in_Mem_debug ) {
                check_in_Mem( 1, "allocate_in_Mem" );
            }
            if ( Mem[hdr+1] == Allocate_Block_Last ) {
                Mem[hdr] = Allocate_Block_InUse;
                Mem[next_hdr] = Allocate_Block_Free;
                Mem[next_hdr+1] = Allocate_Block_Last;
                Mem[hdr+1] = next_hdr;
                rc = hdr + 2;
                Allocated_Blocks++;
                if ( in_Mem_debug ) {
                    printf("-- allocate_in_Mem 1\n");
                }
                return rc;
            }
            else if ( Mem[hdr+1] == next_hdr ||
                      Mem[hdr+1] == next_hdr+1 ) {
                Mem[hdr] = Allocate_Block_InUse;
                rc = hdr + 2;
                Allocated_Blocks++;
                if ( in_Mem_debug ) {
                    printf("-- allocate_in_Mem 2\n");
                }
                return rc;
            }
            else if ( Mem[hdr+1] > next_hdr ) {
                Mem[hdr] = Allocate_Block_InUse;
                Mem[next_hdr+1] = Mem[hdr+1];
                Mem[hdr+1] = next_hdr;
                Mem[next_hdr] = Allocate_Block_Free;
                rc = hdr + 2;
                Allocated_Blocks++;
                if ( in_Mem_debug ) {
                    printf("-- allocate_in_Mem 3\n");
                }
                return rc;
            }
        }
        if ( Mem[hdr+1] == Allocate_Block_Last ) break;
    }

    if ( Mem[hdr+1] >= SR ) {
        printf( "F24 Runtime Error: allocate_in_Mem heap overflow\n" );
        f24_exit( 3 );
    }

    return rc;
}

void free_in_Mem( int ptr ) {

    /*****************************************************************
     *
     * Free memory in the heap.
     *
     *    - Check for illegal pointers
     *    - Mark block as Free
     *    - Combine adjacent Free blocks
     *    - Increment counter for freed blocks
     *
     ****************************************************************/

    int     hdr;

    if ( ptr < Allocate_Block_Header ||
         ptr+Allocate_Block_Header >= F24_MemSize ) {
        printf( "F24 Runtime Error: free_in_Mem ptr out of bounds\n" );
        f24_exit( 1 );
    }

    hdr = ptr - 2;
    if ( Mem[hdr] != Allocate_Block_InUse ) {
        printf( "F24 Runtime Error: free_in_Mem ptr to unallocated block\n" );
        f24_exit( 2 );
    }

    Mem[hdr] = Allocate_Block_Free;
    combine_in_Mem( hdr );
    Freed_Blocks++;
}

/***************************************************************************** 
 *
 * The compiled code from your compiler is included here automatically
 *
 *****************************************************************************/

#include "yourmain.h"


/***************************************************************************** 
 *
 * The main program for the virtual machine environment
 *
 *****************************************************************************/

int main(int argc, char **argv) {

    int     i;

    /*****************************************************************
     *
     * Set up the stack:  
     *     -  Initially points the end of memory.
     *     -  Push something onto the stack by decrementing SR.
     *     -  Pop something off the stack by decrementing SR.
     * Then initialize the following:
     *     -  Stack register
     *     -  Frame register
     *     -  Timer register
     *     -  FMem alias
     *     -  SMem alias
     *
     ****************************************************************/

    SR = F24_MemSize-1;
    FR = SR;
    F24_Time = 0;

    FMem = (double*)Mem;
    SMem = (char*)Mem;

    /*****************************************************************
     *
     * Clear all registers and the main memory.
     *
     ****************************************************************/

    for( i = 0; i < F24_RSize; i++ ) R[i] = 0;
    for( i = 0; i < F24_FSize; i++ ) F[i] = 0.0;
    for( i = 0; i < F24_MemSize; i++ ) Mem[i] = 0;

    /*****************************************************************
     *
     * Intialize the heap
     *
     ****************************************************************/

    init_in_Mem();

    /*****************************************************************
     *
     * Call the compiled code (written in pidgeon C).
     * Call the exit routine to print final information.
     *
     ****************************************************************/

    i = yourmain();
    f24_exit( i );

return 0;
}
